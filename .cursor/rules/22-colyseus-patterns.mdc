---
description: Colyseus multiplayer room schema, messages, and connection patterns
globs: server/src/colyseus/**,client/src/hooks/**
alwaysApply: false
---

# Colyseus Multiplayer Patterns

## Room

- Room name: `"shard"`, one instance per classroom.
- Defined in `server/src/colyseus/rooms/ShardRoom.ts`.
- State schema in `server/src/colyseus/schema/ShardState.ts`.
- **Use `client.send(type, data)` not `this.send(client, type, data)`.** The latter is deprecated in Colyseus 0.16.

## ShardState Schema

- `players`: `MapSchema<PlayerSchema>` keyed by sessionId.
- `tiles`: `MapSchema<TileSchema>` (32x32 world grid).
- `worldObjects`: `MapSchema<WorldObjectSchema>` keyed by `"mapKey:gridX,gridY"` (map-scoped).
- `classroomId`: string.

## WorldObjectSchema Fields

`objectId`, `mapKey`, `definitionId`, `gridX`, `gridY`, `health`, `maxHealth`.

World objects are scoped per map via their `mapKey` field and composite key format `"mapKey:gridX,gridY"`.
Use `worldObjectKey(mapKey, gridX, gridY)` to build keys. Client filters by `currentMapKey` when rendering.

## PlayerSchema Fields

`id`, `gridX`, `gridY`, `stamina`, `maxStamina`, `lastAttackAtMs`,
`equippedHandItemId`, `equippedHeadItemId` (inventory instance IDs),
`equippedHandDefId`, `equippedHeadDefId` (definition IDs for remote client sprite rendering),
`currentMapKey` (tracks which map the player is on).

## Messages (from `@odyssey/shared` enums)

Both enums are **additive-only** — new message types may be added but existing values must not be renamed or removed.

| Client -> Server | Payload |
|---|---|
| `Move` | `{ gridX, gridY }` |
| `SetMap` | `{ mapKey }` |
| `AttackTarget` | `{ gridX, gridY }` — damage world object at tile |
| `OpenContainer` | `{ objectId }` |
| `ClaimContainer` | `{ objectId, nonce }` |
| `EquipItem` | `{ instanceId }` |
| `UnequipItem` | `{ slot }` |
| `DropItem` | `{ instanceId }` — destroys item (Important items rejected) |
| `UseItem` | (planned) |

| Server -> Client | Payload |
|---|---|
| `Notification` | `string` (error/info text) |
| `ContainerContents` | `{ objectId, nonce, items, currencyRewards }` |
| `InventoryUpdate` | `ItemInstance[]` (full snapshot replace) |
| `CurrencyUpdate` | `Record<CurrencyType, number>` (full snapshot) |
| `EquipmentUpdate` | `Record<EquipmentSlot, string \| null>` (full snapshot; sent on join, equip, unequip) |
| `ObjectDamaged` | `{ objectId, newHealth, maxHealth, damage }` (broadcast) |
| `ObjectDestroyed` | `{ objectId }` (broadcast) |
| `LootDropPreview` | `{ items: { definitionId, name, quantity, rarity }[] }` (to attacker only) |

### Adding a New Message

1. Add the value to `ClientMessage` or `ServerMessage` enum in `packages/shared/src/types/messages.ts`.
2. Add a Zod payload schema in `packages/shared/src/validators/`.
3. Register the `onMessage` handler in `ShardRoom.registerMessageHandlers()`.
4. Add the client-side sender in `gameRoomBridge` store and/or listener in `useColyseusRoom`.

## World Object Placement (Hybrid)

World objects (trees, rocks) are placed per-map via two mechanisms:

1. **Manual (Tiled)**: Place objects with `type: "world_object"` and `definition_id` property in the map's `objects` layer. Parsed by `TiledMapParser` into `worldObjectPlacements[]`.
2. **Procedural**: Use `generateProceduralPlacements()` from `mapPlacement.ts` with density/spacing rules and a seeded RNG.

Server loads all map placements at boot via `loadAllMapPlacements()` and passes them to `ShardRoom` via `RoomServices.mapPlacements`. On room creation, `spawnWorldObjectsForMap()` is called for each map.

Key files:
- `server/src/colyseus/services/mapPlacement.ts` — `extractWorldObjectPlacements()`, `generateProceduralPlacements()`, `loadAllMapPlacements()`
- `server/src/colyseus/schema/ShardState.ts` — `spawnWorldObjectsForMap()`, `worldObjectKey()`

## Damage System (Attack Flow)

1. Client sends `ClientMessage.AttackTarget` with `{ gridX, gridY }`.
2. Server builds map-scoped key using `worldObjectKey(player.currentMapKey, gridX, gridY)`.
3. Validates equipped item has `baseDamage > 0`, rate cooldown passed, target in range.
4. `damageService.calculateDamage()` computes `baseDamage * highestMatchingTagModifier`.
5. Server applies damage to `WorldObjectSchema.health`, broadcasts `ServerMessage.ObjectDamaged`.
6. If health reaches 0: resolves drops via `LootResolver`, grants items to attacker, sends `InventoryUpdate` + `LootDropPreview` (with item names/rarities) to attacker, broadcasts `ServerMessage.ObjectDestroyed`, removes world object from state. Client shows loot panel (shared with container UI).

Key functions in `server/src/colyseus/services/damageService.ts`:
- `calculateDamage(params, targetTags)` — damage with tag multiplier
- `canAttack(lastAttackAtMs, rate, nowMs)` — rate-limit check
- `isInRange(playerX, playerY, targetX, targetY, range)` — Chebyshev distance

## Auth Flow

`ShardRoom.onAuth()` validates JWT via `AuthService` and checks classroom membership via `ClassroomService`.

## onJoin Seeding

On first join (empty inventory), server seeds starter items (axe, watering-can, seeds-bag) and auto-equips axe.
Race condition on reconnect handled by catching duplicate key errors (pg error 23505).

## Client Connection

1. `useColyseusRoom` hook creates Colyseus client and calls `joinOrCreate("shard", { accessToken, classroomId })`.
2. Room ref stored in `gameRoomBridge` Zustand store.
3. `RemotePlayersController` reads room state to reconcile remote player sprites + equipment.
4. Listeners for `Notification`, `ContainerContents`, `LootDropPreview`, `InventoryUpdate`, `EquipmentUpdate`, `CurrencyUpdate`, `ObjectDamaged`, `ObjectDestroyed` registered in `useColyseusRoom`.

## Buffer Size

`Encoder.BUFFER_SIZE` set to 40 KB in `server/src/index.ts` (equipment fields increase encoded state size).
