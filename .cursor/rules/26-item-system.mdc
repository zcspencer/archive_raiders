---
description: Item, inventory, equipment, and container system architecture
globs: server/src/inventory/**,client/src/store/playerInventory.ts,client/src/store/container.ts,client/src/store/currency.ts,client/src/data/itemDefinitions.ts,content/items/**,content/containers/**,content/loot-tables/**
alwaysApply: false
---

# Item System Architecture

## Design Invariants

- **Server is sole source of truth** for inventory, equipment, currency, and container contents.
- Every inventory slot holds 0 or 1 `ItemInstance` stack. Quantity >= 1 while row exists; 0 = delete.
- Loot is **per-player**. Two players opening the same container get independent item instances.
- Equipment references use **instanceId**, not definitionId. Client derives definition from inventory.
- **Equipped items stay in inventory** â€” an "Equipped" badge is shown; item is not removed from grid.
- No negative quantities or balances (DB CHECK constraints + service validation).
- `ItemDefinition.version` incremented on component/param changes (not display changes).

## Data Flow: Container Interaction

1. Player presses X near chest -> `InteractionHandler.handleChest()` sends `ClientMessage.OpenContainer`
2. Server `ContainerService.openContainer()` rolls loot (via `LootResolver` for `drops[]` or direct grant for legacy `loot[]`), returns nonce + preview -> `ServerMessage.ContainerContents`
3. Client shows read-only preview in `ChestTransferPanel`
4. Player clicks Claim -> `ClientMessage.ClaimContainer` with nonce
5. Server grants items/currency, sends `InventoryUpdate` + `CurrencyUpdate` (full snapshots)
6. Client replaces store state; panel closes

## Data Flow: Equipment

1. Client sends `ClientMessage.EquipItem { instanceId }` or `ClientMessage.UnequipItem { slot }`
2. Server validates item exists, has Equippable/Cosmetic component, calls `EquipmentService`
3. Server updates `PlayerSchema` fields (`equippedHandItemId`, `equippedHandDefId`, etc.) via `syncPlayerEquipment()`
4. Server sends `InventoryUpdate` back
5. Remote clients read `equippedHandDefId` / `equippedHeadDefId` from schema for sprite rendering

## Damage System

- Equippable items define `baseDamage`, `tagModifiers`, `rate`, and `range` instead of the old `stats` map.
- World objects (trees, rocks) are `WorldObjectSchema` instances with health, backed by Destroyable component params.
- `damageService.calculateDamage()` computes `baseDamage * highestMatchingTagModifier` (e.g. axe has `{ "tree": 3.0 }`).
- `damageService.canAttack()` enforces rate limiting; `isInRange()` uses Chebyshev distance.
- On destruction, drops are resolved via `LootResolver`, granted to the attacker, and a `LootDropPreview` is sent to display the loot panel.
- On first join, server seeds starter items (axe, watering-can, seeds-bag) and auto-equips axe.

## Data Flow: Destroy-Drop Loot

1. World object health reaches 0 from `AttackTarget` damage.
2. Server resolves drops via `LootResolver`.
3. **If items drop**: grants via `InventoryService.addItems()`, sends `InventoryUpdate` + `LootDropPreview` (with item names/rarities) to attacker. Client opens `useContainerStore` in `"loot_drop"` mode; `ChestTransferPanel` renders loot preview. "Collect" closes panel (no server round-trip; items already granted).
4. **If nothing drops** (e.g. `"nothing"` source selected in a weighted pool): server sends `ServerMessage.Notification` with `"You found nothing."`. Client shows auto-dismissing toast (4s) via `useNotificationStore`.

The loot panel UI (`ChestTransferPanel`) and store (`useContainerStore`) are shared between containers and destroy-drop loot via a `mode` field (`"container"` vs `"loot_drop"`).

## Extending the Item System

- **New item**: add `content/items/<id>.item.json`; the server loads it via `ItemDefinitionLoader`.
- **New component**: add a module in `server/src/inventory/components/`, register in `ComponentRegistry`.
- **New container**: add `content/containers/<id>.container.json`; ensure `id` matches map `objectId`.
- **New loot table**: add `content/loot-tables/<id>.loot-table.json`; reference from container `drops`.
- **New equipment slot**: add to `EQUIPMENT_SLOTS` in shared, extend `EquipmentService` and `PlayerSchema`.

## Key Files

| Layer | File | Purpose |
|-------|------|---------|
| Shared | `types/itemDefinition.ts` | `ItemDefinition`, `ComponentDescriptor` |
| Shared | `types/inventory.ts` | `ItemInstance` |
| Shared | `types/container.ts` | `ContainerDefinition`, payloads |
| Shared | `types/lootTable.ts` | `LootDrop`, `LootTableDefinition`, `ResolvedLoot` |
| Shared | `constants/equipmentAnchors.ts` | Per-slot per-direction sprite anchors |
| Server | `inventory/InventoryService.ts` | Inventory CRUD with slot management |
| Server | `inventory/EquipmentService.ts` | Equip/unequip by slot |
| Server | `inventory/CurrencyService.ts` | Currency balances |
| Server | `inventory/ContainerService.ts` | Open/claim with nonce idempotency |
| Server | `inventory/LootResolver.ts` | Resolves loot drops from table definitions |
| Server | `inventory/LootTableLoader.ts` | Loads loot table JSON at startup |
| Server | `inventory/ItemDefinitionLoader.ts` | Loads item JSON at startup |
| Server | `inventory/components/` | Component registry (Equippable, Cosmetic, Readable, Container, Destroyable) |
| Server | `colyseus/rooms/inventoryTreeUtils.ts` | Nested item tree search helpers |
| Server | `colyseus/services/damageService.ts` | Damage calculation, rate check, range check |
| Client | `store/playerInventory.ts` | Server-authoritative item list |
| Client | `store/container.ts` | Loot preview state (containers + destroy drops) |
| Client | `store/currency.ts` | Currency balances |
| Client | `data/itemDefinitions.ts` | Build-time item definition cache |
| Client | `game/rendering/equippedItemSprite.ts` | Equipment sprite rendering |
